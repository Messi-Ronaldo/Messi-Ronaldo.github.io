# 卷积与多项式基础
### Author : **邹易轩**
## Pre
我们已经学习了多种乘法 那如果多项式与多项式想乘呢？
## 卷积
卷积经常用来表示用两个多项式函数生成第三个多项式函数的运算。一般用 $*$ 表示卷积符号（或直接用乘号），即：
$$h(x)=f(x) * g(x)$$
若将多项式的系数提取，卷积也可看作**两个数组生成第三个数组**的运算。

### 加法卷积
最常规的卷积形式，等价于**多项式乘法**：
$$h[n]=\sum_{i=0}^{n} f[i] g[n-i]$$

### 减法卷积
$$h[x]=\sum_{i=x}^{n} f[i] g[i-x]$$
常规处理方式：翻转 $g$ 数组，令 $g'[i]=g[n-i]$，则：
$$h[x]=\sum_{i=x}^{n} f[i] g[i-x]=\sum_{i=x}^{n} f[i] g'[n-i+x]$$
将加法卷积结果**偏移 $n$** 即可得到 $h[x]$。

### 狄利克雷卷积
常见于数论函数，定义：
$$h(x)=\sum_{i \mid x} f(i) g\left(\frac{x}{i}\right)$$
**暴力计算复杂度**：
- 除狄利克雷卷积（复杂度为调和级数）外，其余卷积均为 $O(n^2)$；

### 注
- 下文以**加速加法卷积（多项式乘法）** 展开核心思路。

---

## 多项式
### 基本定义
多项式是形如以下的求和形式：
$$f(x)=\sum_{i=0}^{n} a_{i} x^{i}$$
- $n$ 次多项式：最高次项的指数为 $n$，共 $n+1$ 项；
- 无穷多项式：最高次项为无穷的多项式；
- 系数 $a_i$ 为多项式的核心特征。

### 两种表示法
#### 1. 系数表示法
用**系数和未知数的求和形式**表示多项式，是多项式的**唯一表示法**，也是最常用的表示法。

#### 2. 点值表示法
任意 $n+1$ 个**横坐标不相同**的点 $(x_i, f(x_i))$，可唯一确定一个 $n$ 次多项式。
**原理**：将 $n+1$ 个点代入多项式，得到 $n+1$ 元一次方程组，该方程组有**唯一解**。

### 多项式的运算
仅考虑**加法**和**乘法**，分别对比**系数表示法**和**点值表示法**（要求横坐标一一对应）的运算规则与复杂度。

#### 系数表示法下的运算
设 $f(x)=\sum_{i=0}^{n} a_{i} x^{i},g(x)=\sum_{i=0}^{n} b_{i} x^{i}$：
**乘法**：多项式乘积的系数为两多项式系数的**加法卷积**，即：
$$f(x) \cdot g(x)=\sum_{i=0}^{2n}\left(\sum_{j+k=i} a_j b_k\right)x^i$$
   对每一项 $x^i$ 需遍历求和，时间复杂度 $O(n^2)$。

#### 点值表示法下的运算
设 $f(x),g(x)$ 的点值表示均为 $\{(x_0,f(x_0)),(x_1,f(x_1)),\dots,(x_n,f(x_n))\}$ 和 $\{(x_0,g(x_0)),(x_1,g(x_1)),\dots,(x_n,g(x_n))\}$：
1. **加法**：点值更新为 $(x_i, f(x_i)+g(x_i))$，时间复杂度 $O(n)$；
2. **乘法**：点值更新为 $(x_i, f(x_i) \cdot g(x_i))$，时间复杂度 $O(n)$。

**核心结论**：点值表示法的多项式乘法效率极高，若能实现**系数↔点值**的高效转换，可大幅降低多项式乘法复杂度。

#### 朴素转换的复杂度
- **系数→点值**：任取 $n+1$ 个点求值，每次求值 $O(n)$，总体 $O(n^2)$；
- **点值→系数**：高斯消元解 $n+1$ 元一次方程组，时间复杂度 $O(n^3)$。

---

## 拉格朗日插值
解决**点值表示法的多项式求值/系数转换**问题，是算法竞赛中常用的插值算法。

### 插值公式
设多项式的点值为 $(x_0,y_0),(x_1,y_1),\dots,(x_n,y_n)$，则多项式的表达式为: 
$$f(x)=\sum_{i=0}^{n} y_{i} \prod_{\substack{j=0 \\ j \neq i}}^{n} \frac{x-x_{j}}{x_{i}-x_{j}}$$
### 公式的数学直觉
本质是构造基函数 $p_i(x)$，满足：
- $x=x_i$ 时, $p_i(x)$ $=$ $1$；
- $x=x_j(j \neq i)$ 时, $p_i(x)$ $=$ $0$。
构造辅助函数 $q_i(x)=\prod_{j \neq i}(x-x_j)$（满足 $x=x_j$ 时为 0），再除以 $q_i(x_i)$ 归一化，最终得到 $p_i(x)=\frac{q_i(x)}{q_i(x_i)}$，即插值公式。

### 核心代码
```cpp
// 拉格朗日插值通用模板：n个点(x[1..n],y[1..n])，求f(m)
template <typename T>
inline auto lagrange(int n, const std::vector<T> &x, const std::vector<T> &y, int m) -> T
{
    T res = 0;
    for (int i = 1; i <= n; ++i)
    {
        T t1 = y[i], t2 = 1;
        for (int j = 1; j <= n; ++j)
            if (i != j)
                t1 *= m - x[j], t2 *= x[i] - x[j];
        res += t1 / t2;
    }
    return res;
}
